{"ast":null,"code":"import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, Output } from '@angular/core';\nimport { FormArray } from '@angular/forms';\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\n/**\n * Check and return true if an object is type of string\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction isString(obj) {\n  return typeof obj === \"string\";\n}\n/**\n * Check and return true if an object not undefined or null\n */\nfunction isPresent(obj) {\n  return obj !== undefined && obj !== null;\n}\n/**\n * Check and return true if an object is type of Function\n */\nfunction isFunction(obj) {\n  return typeof obj === \"function\";\n}\n/**\n * Create Image element with specified url string\n */\nfunction createImage(src) {\n  let img = new HTMLImageElement();\n  img.src = src;\n  return img;\n}\n/**\n * Call the function\n */\nfunction callFun(fun) {\n  return fun();\n}\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nclass DataTransferEffect {\n  constructor(name) {\n    this.name = name;\n  }\n}\nDataTransferEffect.COPY = new DataTransferEffect('copy');\nDataTransferEffect.LINK = new DataTransferEffect('link');\nDataTransferEffect.MOVE = new DataTransferEffect('move');\nDataTransferEffect.NONE = new DataTransferEffect('none');\nclass DragImage {\n  constructor(imageElement, x_offset = 0, y_offset = 0) {\n    this.imageElement = imageElement;\n    this.x_offset = x_offset;\n    this.y_offset = y_offset;\n    if (isString(this.imageElement)) {\n      // Create real image from string source\n      let imgScr = this.imageElement;\n      this.imageElement = new HTMLImageElement();\n      this.imageElement.src = imgScr;\n    }\n  }\n}\nclass DragDropConfig {\n  constructor() {\n    this.onDragStartClass = \"dnd-drag-start\";\n    this.onDragEnterClass = \"dnd-drag-enter\";\n    this.onDragOverClass = \"dnd-drag-over\";\n    this.onSortableDragClass = \"dnd-sortable-drag\";\n    this.dragEffect = DataTransferEffect.MOVE;\n    this.dropEffect = DataTransferEffect.MOVE;\n    this.dragCursor = \"move\";\n    this.defaultCursor = \"pointer\";\n  }\n}\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nvar __decorate$1 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nclass DragDropData {}\nfunction dragDropServiceFactory() {\n  return new DragDropService();\n}\nlet DragDropService = class DragDropService {\n  constructor() {\n    this.allowedDropZones = [];\n  }\n};\nDragDropService.ɵfac = function DragDropService_Factory(t) {\n  return new (t || DragDropService)();\n};\nDragDropService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DragDropService,\n  factory: function (t) {\n    return DragDropService.ɵfac(t);\n  }\n});\nfunction dragDropSortableServiceFactory(config) {\n  return new DragDropSortableService(config);\n}\nlet DragDropSortableService = class DragDropSortableService {\n  constructor(_config) {\n    this._config = _config;\n  }\n  get elem() {\n    return this._elem;\n  }\n  markSortable(elem) {\n    if (isPresent(this._elem)) {\n      this._elem.classList.remove(this._config.onSortableDragClass);\n    }\n    if (isPresent(elem)) {\n      this._elem = elem;\n      this._elem.classList.add(this._config.onSortableDragClass);\n    }\n  }\n};\nDragDropSortableService.ɵfac = function DragDropSortableService_Factory(t) {\n  return new (t || DragDropSortableService)(ɵngcc0.ɵɵinject(DragDropConfig));\n};\nDragDropSortableService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DragDropSortableService,\n  factory: function (t) {\n    return DragDropSortableService.ɵfac(t);\n  }\n});\nDragDropSortableService = __decorate$1([__metadata(\"design:paramtypes\", [DragDropConfig])], DragDropSortableService);\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nvar __decorate$3 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$2 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nlet AbstractComponent = class AbstractComponent {\n  constructor(elemRef, _dragDropService, _config, _cdr) {\n    this._dragDropService = _dragDropService;\n    this._config = _config;\n    this._cdr = _cdr;\n    /**\n     * Whether the object is draggable. Default is true.\n     */\n    this._dragEnabled = false;\n    /**\n     * Allows drop on this element\n     */\n    this.dropEnabled = false;\n    this.dropZones = [];\n    this.cloneItem = false;\n    // Assign default cursor unless overridden\n    this._defaultCursor = _config.defaultCursor;\n    this._elem = elemRef.nativeElement;\n    this._elem.style.cursor = this._defaultCursor; // set default cursor on our element\n    //\n    // DROP events\n    //\n    this._elem.ondragenter = event => {\n      this._onDragEnter(event);\n    };\n    this._elem.ondragover = event => {\n      this._onDragOver(event);\n      //\n      if (event.dataTransfer != null) {\n        event.dataTransfer.dropEffect = this._config.dropEffect.name;\n      }\n      return false;\n    };\n    this._elem.ondragleave = event => {\n      this._onDragLeave(event);\n    };\n    this._elem.ondrop = event => {\n      this._onDrop(event);\n    };\n    //\n    // Drag events\n    //\n    this._elem.onmousedown = event => {\n      this._target = event.target;\n    };\n    this._elem.ondragstart = event => {\n      if (this._dragHandle) {\n        if (!this._dragHandle.contains(this._target)) {\n          event.preventDefault();\n          return;\n        }\n      }\n      this._onDragStart(event);\n      //\n      if (event.dataTransfer != null) {\n        event.dataTransfer.setData('text', '');\n        // Change drag effect\n        event.dataTransfer.effectAllowed = this.effectAllowed || this._config.dragEffect.name;\n        // Change drag image\n        if (isPresent(this.dragImage)) {\n          if (isString(this.dragImage)) {\n            event.dataTransfer.setDragImage(createImage(this.dragImage));\n          } else if (isFunction(this.dragImage)) {\n            event.dataTransfer.setDragImage(callFun(this.dragImage));\n          } else {\n            let img = this.dragImage;\n            event.dataTransfer.setDragImage(img.imageElement, img.x_offset, img.y_offset);\n          }\n        } else if (isPresent(this._config.dragImage)) {\n          let dragImage = this._config.dragImage;\n          event.dataTransfer.setDragImage(dragImage.imageElement, dragImage.x_offset, dragImage.y_offset);\n        } else if (this.cloneItem) {\n          this._dragHelper = this._elem.cloneNode(true);\n          this._dragHelper.classList.add('dnd-drag-item');\n          this._dragHelper.style.position = \"absolute\";\n          this._dragHelper.style.top = \"0px\";\n          this._dragHelper.style.left = \"-1000px\";\n          this._elem.parentElement.appendChild(this._dragHelper);\n          event.dataTransfer.setDragImage(this._dragHelper, event.offsetX, event.offsetY);\n        }\n        // Change drag cursor\n        let cursorelem = this._dragHandle ? this._dragHandle : this._elem;\n        if (this._dragEnabled) {\n          cursorelem.style.cursor = this.effectCursor ? this.effectCursor : this._config.dragCursor;\n        } else {\n          cursorelem.style.cursor = this._defaultCursor;\n        }\n      }\n    };\n    this._elem.ondragend = event => {\n      if (this._elem.parentElement && this._dragHelper) {\n        this._elem.parentElement.removeChild(this._dragHelper);\n      }\n      // console.log('ondragend', event.target);\n      this._onDragEnd(event);\n      // Restore style of dragged element\n      let cursorelem = this._dragHandle ? this._dragHandle : this._elem;\n      cursorelem.style.cursor = this._defaultCursor;\n    };\n  }\n  set dragEnabled(enabled) {\n    this._dragEnabled = !!enabled;\n    this._elem.draggable = this._dragEnabled;\n  }\n  get dragEnabled() {\n    return this._dragEnabled;\n  }\n  setDragHandle(elem) {\n    this._dragHandle = elem;\n  }\n  /******* Change detection ******/\n  detectChanges() {\n    // Programmatically run change detection to fix issue in Safari\n    setTimeout(() => {\n      if (this._cdr && !this._cdr.destroyed) {\n        this._cdr.detectChanges();\n      }\n    }, 250);\n  }\n  //****** Droppable *******//\n  _onDragEnter(event) {\n    // console.log('ondragenter._isDropAllowed', this._isDropAllowed);\n    if (this._isDropAllowed(event)) {\n      // event.preventDefault();\n      this._onDragEnterCallback(event);\n    }\n  }\n  _onDragOver(event) {\n    // // console.log('ondragover._isDropAllowed', this._isDropAllowed);\n    if (this._isDropAllowed(event)) {\n      // The element is over the same source element - do nothing\n      if (event.preventDefault) {\n        // Necessary. Allows us to drop.\n        event.preventDefault();\n      }\n      this._onDragOverCallback(event);\n    }\n  }\n  _onDragLeave(event) {\n    // console.log('ondragleave._isDropAllowed', this._isDropAllowed);\n    if (this._isDropAllowed(event)) {\n      // event.preventDefault();\n      this._onDragLeaveCallback(event);\n    }\n  }\n  _onDrop(event) {\n    // console.log('ondrop._isDropAllowed', this._isDropAllowed);\n    if (this._isDropAllowed(event)) {\n      // Necessary. Allows us to drop.\n      this._preventAndStop(event);\n      this._onDropCallback(event);\n      this.detectChanges();\n    }\n  }\n  _isDropAllowed(event) {\n    if ((this._dragDropService.isDragged || event.dataTransfer && event.dataTransfer.files) && this.dropEnabled) {\n      // First, if `allowDrop` is set, call it to determine whether the\n      // dragged element can be dropped here.\n      if (this.allowDrop) {\n        return this.allowDrop(this._dragDropService.dragData);\n      }\n      // Otherwise, use dropZones if they are set.\n      if (this.dropZones.length === 0 && this._dragDropService.allowedDropZones.length === 0) {\n        return true;\n      }\n      for (let i = 0; i < this._dragDropService.allowedDropZones.length; i++) {\n        let dragZone = this._dragDropService.allowedDropZones[i];\n        if (this.dropZones.indexOf(dragZone) !== -1) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  _preventAndStop(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n  //*********** Draggable **********//\n  _onDragStart(event) {\n    //console.log('ondragstart.dragEnabled', this._dragEnabled);\n    if (this._dragEnabled) {\n      this._dragDropService.allowedDropZones = this.dropZones;\n      // console.log('ondragstart.allowedDropZones', this._dragDropService.allowedDropZones);\n      this._onDragStartCallback(event);\n    }\n  }\n  _onDragEnd(event) {\n    this._dragDropService.allowedDropZones = [];\n    // console.log('ondragend.allowedDropZones', this._dragDropService.allowedDropZones);\n    this._onDragEndCallback(event);\n  }\n  //**** Drop Callbacks ****//\n  _onDragEnterCallback(event) {}\n  _onDragOverCallback(event) {}\n  _onDragLeaveCallback(event) {}\n  _onDropCallback(event) {}\n  //**** Drag Callbacks ****//\n  _onDragStartCallback(event) {}\n  _onDragEndCallback(event) {}\n};\nAbstractComponent.ɵfac = function AbstractComponent_Factory(t) {\n  return new (t || AbstractComponent)(ɵngcc0.ɵɵinject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinject(DragDropService), ɵngcc0.ɵɵinject(DragDropConfig), ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef));\n};\nAbstractComponent.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: AbstractComponent,\n  factory: function (t) {\n    return AbstractComponent.ɵfac(t);\n  }\n});\nAbstractComponent = __decorate$3([__metadata$2(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, ChangeDetectorRef])], AbstractComponent);\nclass AbstractHandleComponent {\n  constructor(elemRef, _dragDropService, _config, _Component, _cdr) {\n    this._dragDropService = _dragDropService;\n    this._config = _config;\n    this._Component = _Component;\n    this._cdr = _cdr;\n    this._elem = elemRef.nativeElement;\n    this._Component.setDragHandle(this._elem);\n  }\n}\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nvar __decorate$2 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$1 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nlet DraggableComponent = class DraggableComponent extends AbstractComponent {\n  constructor(elemRef, dragDropService, config, cdr) {\n    super(elemRef, dragDropService, config, cdr);\n    /**\n     * Callback function called when the drag actions happened.\n     */\n    this.onDragStart = new EventEmitter();\n    this.onDragEnd = new EventEmitter();\n    /**\n     * Callback function called when the drag action ends with a valid drop action.\n     * It is activated after the on-drop-success callback\n     */\n    this.onDragSuccessCallback = new EventEmitter();\n    this._defaultCursor = this._elem.style.cursor;\n    this.dragEnabled = true;\n  }\n  set draggable(value) {\n    this.dragEnabled = !!value;\n  }\n  set dropzones(value) {\n    this.dropZones = value;\n  }\n  /**\n   * Drag allowed effect\n   */\n  set effectallowed(value) {\n    this.effectAllowed = value;\n  }\n  /**\n   * Drag effect cursor\n   */\n  set effectcursor(value) {\n    this.effectCursor = value;\n  }\n  _onDragStartCallback(event) {\n    this._dragDropService.isDragged = true;\n    this._dragDropService.dragData = this.dragData;\n    this._dragDropService.onDragSuccessCallback = this.onDragSuccessCallback;\n    this._elem.classList.add(this._config.onDragStartClass);\n    //\n    this.onDragStart.emit({\n      dragData: this.dragData,\n      mouseEvent: event\n    });\n  }\n  _onDragEndCallback(event) {\n    this._dragDropService.isDragged = false;\n    this._dragDropService.dragData = null;\n    this._dragDropService.onDragSuccessCallback = null;\n    this._elem.classList.remove(this._config.onDragStartClass);\n    //\n    this.onDragEnd.emit({\n      dragData: this.dragData,\n      mouseEvent: event\n    });\n  }\n};\nDraggableComponent.ɵfac = function DraggableComponent_Factory(t) {\n  return new (t || DraggableComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragDropService), ɵngcc0.ɵɵdirectiveInject(DragDropConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\nDraggableComponent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DraggableComponent,\n  selectors: [[\"\", \"dnd-draggable\", \"\"]],\n  inputs: {\n    draggable: [\"dragEnabled\", \"draggable\"],\n    dropzones: [\"dropZones\", \"dropzones\"],\n    effectallowed: [\"effectAllowed\", \"effectallowed\"],\n    effectcursor: [\"effectCursor\", \"effectcursor\"],\n    dragData: \"dragData\",\n    dragImage: \"dragImage\",\n    cloneItem: \"cloneItem\"\n  },\n  outputs: {\n    onDragStart: \"onDragStart\",\n    onDragEnd: \"onDragEnd\",\n    onDragSuccessCallback: \"onDragSuccess\"\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n__decorate$2([Input(\"dragEnabled\"), __metadata$1(\"design:type\", Boolean), __metadata$1(\"design:paramtypes\", [Boolean])], DraggableComponent.prototype, \"draggable\", null);\n__decorate$2([Output(), __metadata$1(\"design:type\", EventEmitter)], DraggableComponent.prototype, \"onDragStart\", void 0);\n__decorate$2([Output(), __metadata$1(\"design:type\", EventEmitter)], DraggableComponent.prototype, \"onDragEnd\", void 0);\n__decorate$2([Input(), __metadata$1(\"design:type\", Object)], DraggableComponent.prototype, \"dragData\", void 0);\n__decorate$2([Output(\"onDragSuccess\"), __metadata$1(\"design:type\", EventEmitter)], DraggableComponent.prototype, \"onDragSuccessCallback\", void 0);\n__decorate$2([Input(\"dropZones\"), __metadata$1(\"design:type\", Array), __metadata$1(\"design:paramtypes\", [Array])], DraggableComponent.prototype, \"dropzones\", null);\n__decorate$2([Input(\"effectAllowed\"), __metadata$1(\"design:type\", String), __metadata$1(\"design:paramtypes\", [String])], DraggableComponent.prototype, \"effectallowed\", null);\n__decorate$2([Input(\"effectCursor\"), __metadata$1(\"design:type\", String), __metadata$1(\"design:paramtypes\", [String])], DraggableComponent.prototype, \"effectcursor\", null);\n__decorate$2([Input(), __metadata$1(\"design:type\", Object)], DraggableComponent.prototype, \"dragImage\", void 0);\n__decorate$2([Input(), __metadata$1(\"design:type\", Boolean)], DraggableComponent.prototype, \"cloneItem\", void 0);\nDraggableComponent = __decorate$2([__metadata$1(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, ChangeDetectorRef])], DraggableComponent);\nlet DraggableHandleComponent = class DraggableHandleComponent extends AbstractHandleComponent {\n  constructor(elemRef, dragDropService, config, _Component, cdr) {\n    super(elemRef, dragDropService, config, _Component, cdr);\n  }\n};\nDraggableHandleComponent.ɵfac = function DraggableHandleComponent_Factory(t) {\n  return new (t || DraggableHandleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragDropService), ɵngcc0.ɵɵdirectiveInject(DragDropConfig), ɵngcc0.ɵɵdirectiveInject(DraggableComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\nDraggableHandleComponent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DraggableHandleComponent,\n  selectors: [[\"\", \"dnd-draggable-handle\", \"\"]],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nDraggableHandleComponent = __decorate$2([__metadata$1(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, DraggableComponent, ChangeDetectorRef])], DraggableHandleComponent);\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nvar __decorate$4 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$3 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nlet DroppableComponent = class DroppableComponent extends AbstractComponent {\n  constructor(elemRef, dragDropService, config, cdr) {\n    super(elemRef, dragDropService, config, cdr);\n    /**\n     * Callback function called when the drop action completes correctly.\n     * It is activated before the on-drag-success callback.\n     */\n    this.onDropSuccess = new EventEmitter();\n    this.onDragEnter = new EventEmitter();\n    this.onDragOver = new EventEmitter();\n    this.onDragLeave = new EventEmitter();\n    this.dropEnabled = true;\n  }\n  set droppable(value) {\n    this.dropEnabled = !!value;\n  }\n  set allowdrop(value) {\n    this.allowDrop = value;\n  }\n  set dropzones(value) {\n    this.dropZones = value;\n  }\n  /**\n   * Drag allowed effect\n   */\n  set effectallowed(value) {\n    this.effectAllowed = value;\n  }\n  /**\n   * Drag effect cursor\n   */\n  set effectcursor(value) {\n    this.effectCursor = value;\n  }\n  _onDragEnterCallback(event) {\n    if (this._dragDropService.isDragged) {\n      this._elem.classList.add(this._config.onDragEnterClass);\n      this.onDragEnter.emit({\n        dragData: this._dragDropService.dragData,\n        mouseEvent: event\n      });\n    }\n  }\n  _onDragOverCallback(event) {\n    if (this._dragDropService.isDragged) {\n      this._elem.classList.add(this._config.onDragOverClass);\n      this.onDragOver.emit({\n        dragData: this._dragDropService.dragData,\n        mouseEvent: event\n      });\n    }\n  }\n  _onDragLeaveCallback(event) {\n    if (this._dragDropService.isDragged) {\n      this._elem.classList.remove(this._config.onDragOverClass);\n      this._elem.classList.remove(this._config.onDragEnterClass);\n      this.onDragLeave.emit({\n        dragData: this._dragDropService.dragData,\n        mouseEvent: event\n      });\n    }\n  }\n  _onDropCallback(event) {\n    let dataTransfer = event.dataTransfer;\n    if (this._dragDropService.isDragged || dataTransfer && dataTransfer.files) {\n      this.onDropSuccess.emit({\n        dragData: this._dragDropService.dragData,\n        mouseEvent: event\n      });\n      if (this._dragDropService.onDragSuccessCallback) {\n        this._dragDropService.onDragSuccessCallback.emit({\n          dragData: this._dragDropService.dragData,\n          mouseEvent: event\n        });\n      }\n      this._elem.classList.remove(this._config.onDragOverClass);\n      this._elem.classList.remove(this._config.onDragEnterClass);\n    }\n  }\n};\nDroppableComponent.ɵfac = function DroppableComponent_Factory(t) {\n  return new (t || DroppableComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragDropService), ɵngcc0.ɵɵdirectiveInject(DragDropConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\nDroppableComponent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DroppableComponent,\n  selectors: [[\"\", \"dnd-droppable\", \"\"]],\n  inputs: {\n    droppable: [\"dropEnabled\", \"droppable\"],\n    allowdrop: [\"allowDrop\", \"allowdrop\"],\n    dropzones: [\"dropZones\", \"dropzones\"],\n    effectallowed: [\"effectAllowed\", \"effectallowed\"],\n    effectcursor: [\"effectCursor\", \"effectcursor\"]\n  },\n  outputs: {\n    onDropSuccess: \"onDropSuccess\",\n    onDragEnter: \"onDragEnter\",\n    onDragOver: \"onDragOver\",\n    onDragLeave: \"onDragLeave\"\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n__decorate$4([Input(\"dropEnabled\"), __metadata$3(\"design:type\", Boolean), __metadata$3(\"design:paramtypes\", [Boolean])], DroppableComponent.prototype, \"droppable\", null);\n__decorate$4([Output(), __metadata$3(\"design:type\", EventEmitter)], DroppableComponent.prototype, \"onDropSuccess\", void 0);\n__decorate$4([Output(), __metadata$3(\"design:type\", EventEmitter)], DroppableComponent.prototype, \"onDragEnter\", void 0);\n__decorate$4([Output(), __metadata$3(\"design:type\", EventEmitter)], DroppableComponent.prototype, \"onDragOver\", void 0);\n__decorate$4([Output(), __metadata$3(\"design:type\", EventEmitter)], DroppableComponent.prototype, \"onDragLeave\", void 0);\n__decorate$4([Input(\"allowDrop\"), __metadata$3(\"design:type\", Function), __metadata$3(\"design:paramtypes\", [Function])], DroppableComponent.prototype, \"allowdrop\", null);\n__decorate$4([Input(\"dropZones\"), __metadata$3(\"design:type\", Array), __metadata$3(\"design:paramtypes\", [Array])], DroppableComponent.prototype, \"dropzones\", null);\n__decorate$4([Input(\"effectAllowed\"), __metadata$3(\"design:type\", String), __metadata$3(\"design:paramtypes\", [String])], DroppableComponent.prototype, \"effectallowed\", null);\n__decorate$4([Input(\"effectCursor\"), __metadata$3(\"design:type\", String), __metadata$3(\"design:paramtypes\", [String])], DroppableComponent.prototype, \"effectcursor\", null);\nDroppableComponent = __decorate$4([__metadata$3(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, ChangeDetectorRef])], DroppableComponent);\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nvar __decorate$5 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$4 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nlet SortableContainer = class SortableContainer extends AbstractComponent {\n  constructor(elemRef, dragDropService, config, cdr, _sortableDataService) {\n    super(elemRef, dragDropService, config, cdr);\n    this._sortableDataService = _sortableDataService;\n    this._sortableData = [];\n    this.dragEnabled = false;\n  }\n  set draggable(value) {\n    this.dragEnabled = !!value;\n  }\n  set sortableData(sortableData) {\n    this._sortableData = sortableData;\n    if (sortableData instanceof FormArray) {\n      this.sortableHandler = new SortableFormArrayHandler();\n    } else {\n      this.sortableHandler = new SortableArrayHandler();\n    }\n    //\n    this.dropEnabled = !!this._sortableData;\n    // console.log(\"collection is changed, drop enabled: \" + this.dropEnabled);\n  }\n\n  get sortableData() {\n    return this._sortableData;\n  }\n  set dropzones(value) {\n    this.dropZones = value;\n  }\n  _onDragEnterCallback(event) {\n    if (this._sortableDataService.isDragged) {\n      let item = this._sortableDataService.sortableContainer.getItemAt(this._sortableDataService.index);\n      // Check does element exist in sortableData of this Container\n      if (this.indexOf(item) === -1) {\n        // Let's add it\n        // console.log('Container._onDragEnterCallback. drag node [' + this._sortableDataService.index.toString() + '] over parent node');\n        // Remove item from previouse list\n        this._sortableDataService.sortableContainer.removeItemAt(this._sortableDataService.index);\n        if (this._sortableDataService.sortableContainer._sortableData.length === 0) {\n          this._sortableDataService.sortableContainer.dropEnabled = true;\n        }\n        // Add item to new list\n        this.insertItemAt(item, 0);\n        this._sortableDataService.sortableContainer = this;\n        this._sortableDataService.index = 0;\n      }\n      // Refresh changes in properties of container component\n      this.detectChanges();\n    }\n  }\n  getItemAt(index) {\n    return this.sortableHandler.getItemAt(this._sortableData, index);\n  }\n  indexOf(item) {\n    return this.sortableHandler.indexOf(this._sortableData, item);\n  }\n  removeItemAt(index) {\n    this.sortableHandler.removeItemAt(this._sortableData, index);\n  }\n  insertItemAt(item, index) {\n    this.sortableHandler.insertItemAt(this._sortableData, item, index);\n  }\n};\nSortableContainer.ɵfac = function SortableContainer_Factory(t) {\n  return new (t || SortableContainer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragDropService), ɵngcc0.ɵɵdirectiveInject(DragDropConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DragDropSortableService));\n};\nSortableContainer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SortableContainer,\n  selectors: [[\"\", \"dnd-sortable-container\", \"\"]],\n  inputs: {\n    draggable: [\"dragEnabled\", \"draggable\"],\n    sortableData: \"sortableData\",\n    dropzones: [\"dropZones\", \"dropzones\"]\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n__decorate$5([Input(\"dragEnabled\"), __metadata$4(\"design:type\", Boolean), __metadata$4(\"design:paramtypes\", [Boolean])], SortableContainer.prototype, \"draggable\", null);\n__decorate$5([Input(), __metadata$4(\"design:type\", Object), __metadata$4(\"design:paramtypes\", [Object])], SortableContainer.prototype, \"sortableData\", null);\n__decorate$5([Input(\"dropZones\"), __metadata$4(\"design:type\", Array), __metadata$4(\"design:paramtypes\", [Array])], SortableContainer.prototype, \"dropzones\", null);\nSortableContainer = __decorate$5([__metadata$4(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, ChangeDetectorRef, DragDropSortableService])], SortableContainer);\nclass SortableArrayHandler {\n  getItemAt(sortableData, index) {\n    return sortableData[index];\n  }\n  indexOf(sortableData, item) {\n    return sortableData.indexOf(item);\n  }\n  removeItemAt(sortableData, index) {\n    sortableData.splice(index, 1);\n  }\n  insertItemAt(sortableData, item, index) {\n    sortableData.splice(index, 0, item);\n  }\n}\nclass SortableFormArrayHandler {\n  getItemAt(sortableData, index) {\n    return sortableData.at(index);\n  }\n  indexOf(sortableData, item) {\n    return sortableData.controls.indexOf(item);\n  }\n  removeItemAt(sortableData, index) {\n    sortableData.removeAt(index);\n  }\n  insertItemAt(sortableData, item, index) {\n    sortableData.insert(index, item);\n  }\n}\nlet SortableComponent = class SortableComponent extends AbstractComponent {\n  constructor(elemRef, dragDropService, config, _sortableContainer, _sortableDataService, cdr) {\n    super(elemRef, dragDropService, config, cdr);\n    this._sortableContainer = _sortableContainer;\n    this._sortableDataService = _sortableDataService;\n    /**\n     * Callback function called when the drag action ends with a valid drop action.\n     * It is activated after the on-drop-success callback\n     */\n    this.onDragSuccessCallback = new EventEmitter();\n    this.onDragStartCallback = new EventEmitter();\n    this.onDragOverCallback = new EventEmitter();\n    this.onDragEndCallback = new EventEmitter();\n    this.onDropSuccessCallback = new EventEmitter();\n    this.dropZones = this._sortableContainer.dropZones;\n    this.dragEnabled = true;\n    this.dropEnabled = true;\n  }\n  set draggable(value) {\n    this.dragEnabled = !!value;\n  }\n  set droppable(value) {\n    this.dropEnabled = !!value;\n  }\n  /**\n   * Drag allowed effect\n   */\n  set effectallowed(value) {\n    this.effectAllowed = value;\n  }\n  /**\n   * Drag effect cursor\n   */\n  set effectcursor(value) {\n    this.effectCursor = value;\n  }\n  _onDragStartCallback(event) {\n    // console.log('_onDragStartCallback. dragging elem with index ' + this.index);\n    this._sortableDataService.isDragged = true;\n    this._sortableDataService.sortableContainer = this._sortableContainer;\n    this._sortableDataService.index = this.index;\n    this._sortableDataService.markSortable(this._elem);\n    // Add dragData\n    this._dragDropService.isDragged = true;\n    this._dragDropService.dragData = this.dragData;\n    this._dragDropService.onDragSuccessCallback = this.onDragSuccessCallback;\n    //\n    this.onDragStartCallback.emit(this._dragDropService.dragData);\n  }\n  _onDragOverCallback(event) {\n    if (this._sortableDataService.isDragged && this._elem !== this._sortableDataService.elem) {\n      // console.log('_onDragOverCallback. dragging elem with index ' + this.index);\n      this._sortableDataService.sortableContainer = this._sortableContainer;\n      this._sortableDataService.index = this.index;\n      this._sortableDataService.markSortable(this._elem);\n      this.onDragOverCallback.emit(this._dragDropService.dragData);\n    }\n  }\n  _onDragEndCallback(event) {\n    // console.log('_onDragEndCallback. end dragging elem with index ' + this.index);\n    this._sortableDataService.isDragged = false;\n    this._sortableDataService.sortableContainer = null;\n    this._sortableDataService.index = null;\n    this._sortableDataService.markSortable(null);\n    // Add dragGata\n    this._dragDropService.isDragged = false;\n    this._dragDropService.dragData = null;\n    this._dragDropService.onDragSuccessCallback = null;\n    //\n    this.onDragEndCallback.emit(this._dragDropService.dragData);\n  }\n  _onDragEnterCallback(event) {\n    if (this._sortableDataService.isDragged) {\n      this._sortableDataService.markSortable(this._elem);\n      if (this.index !== this._sortableDataService.index || this._sortableDataService.sortableContainer.sortableData !== this._sortableContainer.sortableData) {\n        // console.log('Component._onDragEnterCallback. drag node [' + this.index + '] over node [' + this._sortableDataService.index + ']');\n        // Get item\n        let item = this._sortableDataService.sortableContainer.getItemAt(this._sortableDataService.index);\n        // Remove item from previouse list\n        this._sortableDataService.sortableContainer.removeItemAt(this._sortableDataService.index);\n        if (this._sortableDataService.sortableContainer.sortableData.length === 0) {\n          this._sortableDataService.sortableContainer.dropEnabled = true;\n        }\n        // Add item to new list\n        this._sortableContainer.insertItemAt(item, this.index);\n        if (this._sortableContainer.dropEnabled) {\n          this._sortableContainer.dropEnabled = false;\n        }\n        this._sortableDataService.sortableContainer = this._sortableContainer;\n        this._sortableDataService.index = this.index;\n        this.detectChanges();\n      }\n    }\n  }\n  _onDropCallback(event) {\n    if (this._sortableDataService.isDragged) {\n      // console.log('onDropCallback.onDropSuccessCallback.dragData', this._dragDropService.dragData);\n      this.onDropSuccessCallback.emit(this._dragDropService.dragData);\n      if (this._dragDropService.onDragSuccessCallback) {\n        // console.log('onDropCallback.onDragSuccessCallback.dragData', this._dragDropService.dragData);\n        this._dragDropService.onDragSuccessCallback.emit(this._dragDropService.dragData);\n      }\n      // Refresh changes in properties of container component\n      this._sortableContainer.detectChanges();\n    }\n  }\n};\nSortableComponent.ɵfac = function SortableComponent_Factory(t) {\n  return new (t || SortableComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragDropService), ɵngcc0.ɵɵdirectiveInject(DragDropConfig), ɵngcc0.ɵɵdirectiveInject(SortableContainer), ɵngcc0.ɵɵdirectiveInject(DragDropSortableService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\nSortableComponent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SortableComponent,\n  selectors: [[\"\", \"dnd-sortable\", \"\"]],\n  inputs: {\n    draggable: [\"dragEnabled\", \"draggable\"],\n    droppable: [\"dropEnabled\", \"droppable\"],\n    effectallowed: [\"effectAllowed\", \"effectallowed\"],\n    effectcursor: [\"effectCursor\", \"effectcursor\"],\n    index: [\"sortableIndex\", \"index\"],\n    dragData: \"dragData\"\n  },\n  outputs: {\n    onDragSuccessCallback: \"onDragSuccess\",\n    onDragStartCallback: \"onDragStart\",\n    onDragOverCallback: \"onDragOver\",\n    onDragEndCallback: \"onDragEnd\",\n    onDropSuccessCallback: \"onDropSuccess\"\n  },\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n__decorate$5([Input('sortableIndex'), __metadata$4(\"design:type\", Number)], SortableComponent.prototype, \"index\", void 0);\n__decorate$5([Input(\"dragEnabled\"), __metadata$4(\"design:type\", Boolean), __metadata$4(\"design:paramtypes\", [Boolean])], SortableComponent.prototype, \"draggable\", null);\n__decorate$5([Input(\"dropEnabled\"), __metadata$4(\"design:type\", Boolean), __metadata$4(\"design:paramtypes\", [Boolean])], SortableComponent.prototype, \"droppable\", null);\n__decorate$5([Input(), __metadata$4(\"design:type\", Object)], SortableComponent.prototype, \"dragData\", void 0);\n__decorate$5([Input(\"effectAllowed\"), __metadata$4(\"design:type\", String), __metadata$4(\"design:paramtypes\", [String])], SortableComponent.prototype, \"effectallowed\", null);\n__decorate$5([Input(\"effectCursor\"), __metadata$4(\"design:type\", String), __metadata$4(\"design:paramtypes\", [String])], SortableComponent.prototype, \"effectcursor\", null);\n__decorate$5([Output(\"onDragSuccess\"), __metadata$4(\"design:type\", EventEmitter)], SortableComponent.prototype, \"onDragSuccessCallback\", void 0);\n__decorate$5([Output(\"onDragStart\"), __metadata$4(\"design:type\", EventEmitter)], SortableComponent.prototype, \"onDragStartCallback\", void 0);\n__decorate$5([Output(\"onDragOver\"), __metadata$4(\"design:type\", EventEmitter)], SortableComponent.prototype, \"onDragOverCallback\", void 0);\n__decorate$5([Output(\"onDragEnd\"), __metadata$4(\"design:type\", EventEmitter)], SortableComponent.prototype, \"onDragEndCallback\", void 0);\n__decorate$5([Output(\"onDropSuccess\"), __metadata$4(\"design:type\", EventEmitter)], SortableComponent.prototype, \"onDropSuccessCallback\", void 0);\nSortableComponent = __decorate$5([__metadata$4(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, SortableContainer, DragDropSortableService, ChangeDetectorRef])], SortableComponent);\nlet SortableHandleComponent = class SortableHandleComponent extends AbstractHandleComponent {\n  constructor(elemRef, dragDropService, config, _Component, cdr) {\n    super(elemRef, dragDropService, config, _Component, cdr);\n  }\n};\nSortableHandleComponent.ɵfac = function SortableHandleComponent_Factory(t) {\n  return new (t || SortableHandleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DragDropService), ɵngcc0.ɵɵdirectiveInject(DragDropConfig), ɵngcc0.ɵɵdirectiveInject(SortableComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\nSortableHandleComponent.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SortableHandleComponent,\n  selectors: [[\"\", \"dnd-sortable-handle\", \"\"]],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nSortableHandleComponent = __decorate$5([__metadata$4(\"design:paramtypes\", [ElementRef, DragDropService, DragDropConfig, SortableComponent, ChangeDetectorRef])], SortableHandleComponent);\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet providers = [DragDropConfig, {\n  provide: DragDropService,\n  useFactory: dragDropServiceFactory\n}, {\n  provide: DragDropSortableService,\n  useFactory: dragDropSortableServiceFactory,\n  deps: [DragDropConfig]\n}];\nlet DndModule = DndModule_1 = class DndModule {\n  static forRoot() {\n    return {\n      ngModule: DndModule_1,\n      providers: providers\n    };\n  }\n};\nDndModule.ɵfac = function DndModule_Factory(t) {\n  return new (t || DndModule)();\n};\nDndModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: DndModule\n});\nDndModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DndModule, {\n    declarations: [DraggableComponent, DraggableHandleComponent, DroppableComponent, SortableContainer, SortableComponent, SortableHandleComponent],\n    exports: [DraggableComponent, DraggableHandleComponent, DroppableComponent, SortableContainer, SortableComponent, SortableHandleComponent]\n  });\n})();\nvar DndModule_1;\n\n// Copyright (C) 2016-2018 Sergey Akopkokhyants\n// This project is licensed under the terms of the MIT license.\n// https://github.com/akserg/ng2-dnd\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { providers, DndModule, AbstractComponent, AbstractHandleComponent, DataTransferEffect, DragImage, DragDropConfig, DragDropData, dragDropServiceFactory, DragDropService, dragDropSortableServiceFactory, DragDropSortableService, DraggableComponent, DraggableHandleComponent, DroppableComponent, SortableContainer, SortableComponent, SortableHandleComponent };\n\n//# sourceMappingURL=ng2-dnd.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}